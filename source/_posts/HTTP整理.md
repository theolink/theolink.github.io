---
title: HTTP整理
date: 2020-09-07 21:45:34
tags:
---



# 概述

HTTP是基于TCP协议的应用层协议

- 作用：规定了服务器与客户端之间的通信格式，主要用于服务器与客户端之间的WEB数据传输。
- 端口：默认80
- 特点：无状态，对事务的处理没有记忆能力，若后续处理需要前面信息则必须重传。

# HTTP版本





![Http版本](https://i.loli.net/2020/09/07/zGkKIYyDlweuhTj.png)



## HTTP/0.9

![Http/0.9](https://i.loli.net/2020/09/07/wEmn9KgZlOXoB3q.png)

### 响应格式单一：HTML

规定服务器只能回应HTML格式的字符串；

### 短连接

每次请求-回应都需要重新建立连接，服务器响应完毕即会关闭TCP连接。

#### 缺点

1. 消耗高：每次建立连接都需要TCP三次握手
2. 响应速度慢：现代网页需要许多请求来提供所需的信息量，每个请求都需要花费时间建立连接，且TCP慢启动使得新连接速度较慢
3. 加重网络拥塞：每次请求都有TCP三次握手的数据包，且请求完毕就关闭连接，TCP没有足够的时间去判断拥塞状态

### 请求方法

- GET

### 请求/响应示例

```
// 请求
GET /index.html   
// 响应
<html> 
<body>Hello World</body>
</html>
```



## HTTP/1.0

![Http/1.0](https://i.loli.net/2020/09/07/WFBouTA4yfv1wKg.png)

### 通信格式：多样化

#### Header

- 每次通信必须包含头信息（Http header），用于描述一些元数据

- 头信息必须为ASCII码，，其中就包括Content-Type，用于标记数据部分的格式

#### 数据部分

可以发送任意格式的数据，包括文本、图片、视频、二进制文件等。

### 短连接

- 默认短连接，但是可以使用非标准的keep-alive字段进行声明，请求服务器不关闭连接
- 在HTTP 1.0中并没有官方提供的标准来规定keep-alive如何运作，因此实际上它是被附加到 HTTP 1.0协议上
- HTTP 1.0使用Content-Length标记响应消息长度，区分多个响应

### keep-alive

如果客户端浏览器支持 Keep-Alive ，那么就在HTTP请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。

#### 区分响应边界：Content-Length

- 通过Content-Length声明本次响应数据部分长度，从而区分本次响应与下次响应的边界
- 缺点：服务器发送前必须知道数据长度才能使用Content-Length。对于动态生成的内容，在内容创建完成之前长度不可知，这时候只能开一个足够大的 buffer，等内容全部生成好再计算长度，内存开销大且响应时间更慢。

### 请求方法

- GET
- POST
- HEAD

### 其他新特性

1. **状态码**

   常见状态码

   ```
   200 OK //客户端请求成功
   301 Moved Permanently //请求永久重定向
   302 Moved Temporarily //请求临时重定向
   304 Not Modified //文件未修改，可以直接使用缓存的文件。
   400 Bad Request //客户端请求有语法错误，不能被服务器所理解
   401 Unauthorized //请求未经授权，
   403 Forbidden //服务器收到请求，但是拒绝提供服务
   404 Not Found //请求资源不存在，eg：输入了错误的URL
   500 Internal Server Error //服务器发生不可预期的错误
   503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
   ```

2. **内容编码（Content-Encoding）**

   由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法；客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法：

   ```
   Content-Encoding: gzip
   Content-Encoding: compress
   Content-Encoding: deflate
   //客户端
   Accept-Encoding: gzip, deflate 
   ```

3. **缓存（cache）**

4. **多部分发送（multi-part type**）

5.  **权限（authorization）**

6.  **多字符集支持**



### 请求/响应示例

```
// 请求
GET /index.html HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: text/plain      //声明能够接受的数据格式类型
Accept-Encoding: gzip, deflate, br   //声明能够接受的数据压缩类型  
// 响应
HTTP/1.0 200 OK           //状态行
Content-Type: text/plain      //数据格式
Content-Length: 137582        //数据包长度
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT //服务端资源上次修改时间
Server: Apache 0.84         //声明服务器类型

<html>  
<body>Hello World</body>
</html>
```



## HTTP/1.1

![Http/1.1](https://i.loli.net/2020/09/07/5TsxcrLBH3kN6mn.png)

### 长连接

- 默认开启Connection: keep-alive，不用显示声明，连接默认不关闭
- 可以通过声明Connection：close关闭连接，或者当发现对方一段时间没活动时关闭连接；

### 分块传输 （Transfer-Encoding: chunked）

- 除使用Content-Length以外，HTTP 1.1还可使用头部字段Transfer-Encoding区分响应边界
- 头信息使用Transfer-Encoding: chunked，表明数据由数量未定的数据块组成，允许服务器一边生成数据，一边响应给客户端，不需要事先知道整个响应内容的大小
- 使用分块传输后，一个响应由多个chunk（块）组成。每个chunk包括一个十六进制长度值和具体数据，长度值独占一行，其值不包含它结尾的CRLF(\r\n)和数据结尾的CRLF(\r\n)。每个响应数据最后一个chunk长度值必须为0，数据为空，标志一个响应结束。
- Transfer-Encoding: chunked表示分块传输，与Content-Encoding不冲突，可以结合使用：先分块再压缩。
- 其他：
  - 为了兼容HTTP/1.0服务端，一个包含消息体的HTTP/1.1请求中头信息必须使用Content-Length，除非知道服务器兼容HTTP/1.1。若没有使用且服务器不兼容HTTP/1.1，则服务器会响应400 (bad request) 或411 (length required，表示服务器坚持希望收到一个合法的Content-Length字段）
  - 所有HTTP/1.1的接收者必须接受分块传输，如果一个消息的头部同时包含transfer-coding:chunked和Content-Length ，则会Content-Length 。

#### 断点续传

断点续传允许连接断开重连后，从上次断开的地方接着传输数据。

基于分块传输特性，HTTP/1.1使用范围请求实现断点续传功能：

1. 服务器响应标头使用Access-Ranges来标记是否支持范围请求
2. 客户端使用标头字段Ranges声明请求的范围，请求指定范围的数据
3. 服务器对于范围请求的响应使用Content-Range来标记响应数据的范围

断点续传请求的资源可能发生变化。可以在If-Range标头字段中使用ETag或Last-Modified参数，判断资源是否发生变化：若没发生变化，则返回206，进行断点续传传输；若发生变化，返回200，从头开始传输。

### HTTP管道

- 默认情况下，HTTP请求是按顺序发出的。仅在收到对当前请求的响应后，才发出下一个请求。而由于网络延迟和带宽的影响，下一个请求会延迟到达服务器。HTTP/1.1支持管道机制，允许在同一个长连接里发送连续的请求而无需等待前面请求的响应到达。
- 这种机制下，服务器处理完一个请求后，立即就能处理下一个请求，而无需等待下一个请求在一定延迟过后到达。
- 但是服务器还是按请求顺序先后对请求进行响应。

#### 缺点：

- 线头阻塞：服务器按序回应，若前一回应特别慢，后续请求则会排队等待
  - 减少连续发送的请求数
  - 多开持久连接，一般为6个
  - 网页优化：合并脚本和样式表、图片嵌入CSS、域名分片等

### 域分片（Sharding）

#### TCP多开

- 由于HTTP/1.x没有多路复用，在HTTP管道机制的条件下，浏览器连续给服务器发送多个串行请求，而服务器只能依次对请求进行处理。为了提高响应速度，浏览器往往同时打开到每个域的多个TCP连接，发送并行请求。（通常为6个，过多可能在服务端出发Dos保护）
- HTTP/1.x下浏览器对同一个域的TCP连接数有限制，对于大型网站显得不适用

#### 域分片

- 将资源放在同一个域的不同子域上，由于主机名不同，相当于隐式增加了浏览器的的连接限制数目。
- 会导致额外的DNS查找。

### 请求方法

- GET
- POST
- HEAD
- PUT
- DELETE
- CONNECT
- OPTIONS
- TRACE

### 其他新特性

#### Host字段

用于指定服务器的域名，可将请求发往同服务器的不同域名，为虚拟主机做铺垫

### 请求/响应示例

```
// 请求
GET /index.html HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: text/plain        //声明能够接受的数据格式类型  
// 响应
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
sequence

0
```



## HTTP/2

![Http/2](https://i.loli.net/2020/09/07/gsHKl1bxviJWBNC.png)

### 多路复用

- HTTP/2基于帧与流的传输模式，通过流标志确定帧所属的流，使得多个请求/响应可以并行交错的发送，互不干扰。
- 优点：

1. 减少了TCP连接数。HTTP/1.x通过多开TCP进行发送并行数据，在HTTP/2中，同一个连接中可以并行交错的传输多个流，互不影响，只需一个TCP连接即可解决HTTP/1.x线头阻塞问题。

#### 帧

- HTTP/2是一个二进制协议，基于帧进行传输。
- HTTP/2将请求/响应拆分成帧进行传输，每个帧由帧头及帧负载组成：帧头定义了负载的长度、帧类型、流标志等信息，帧负载为二进制编码的数据。
- HTTP/2定义了HEADERA、DATA、PRIORITY等10种不同类型的帧

![HTTP/2 帧结构](https://i.loli.net/2020/09/07/t5Au1DgapOJZm2H.png)

#### 流

- 流是HTTP/2中的一种抽象传输通道，可以承载双向的帧数据传输
- 将每个请求或响应的所有数据帧抽象为一个流
- 通过帧头信息的流标志标记帧所属的流

### 标头压缩

在HTTP/1.x中，数据部分一般会经过gzip等格式进行压缩，但标头部分始终以文本形式进行传输。在现代web中，每个网页平均可产生上百个请求，消耗在标头部分的流量变得不可忽视。

HTTP/2使用HPACK协议进行标头压缩，主要有三个关键点：

1. 客户端与服务器共同维护一份相同的静态表（Static Table），包含常见的头部名称，以及常见的头部名称与值的组合；
2. 维护一份相同的动态表（Dynamic Table），可以动态地添加内容；
3. 支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。

#### 静态表

1. 对于完全匹配的头部键值对，例如 :method: GET，可以直接使用静态表索引表示；
2. 对于头部名称可以匹配的键值对，例如 cookie: xxxxxxx，可以将名称使用静态表索引表示，值部分可以采用霍夫曼编码或直接传输

#### 动态表

1. 对于静态表中没有的键值对或只有名字的数据，可以将其添加到动态表中，这样后续的请求/响应即可使用动态表索引来表示
2. 对于某些敏感的标头字段，可以标记其不添加到动态表，以提高安全性。比如用来认证的Cookie。

#### 静态霍夫曼编码

1. HTTP/2提供一个一个静态霍夫曼表，用于数据压缩。

### 服务器推送

一个网页通常包含数个静态资源，浏览器请求该网页的顺序可以总结为：->请求网页->解析网页HTML->发现HTML中的静态资源引用->请求静态资源；而在解析网页到发现静态资源引用再到请求静态资源并得到响应，这期间存在时间的延迟，会影响网页的加载速度。

服务器推送大体流程：

1. 服务器收到客户端的一个请求，在响应这个请求之前，预测客户端在收到这个响应后下一步要请求的资源，然后构造一个PUSH_PROMISE帧发送给客户端，告诉客户端将要推送这些资源
2. 客户端收到PUSH_PROMISE帧过后，即可根据帧里面提供的Promised Stream Id去读后续推过来的资源；若客户端不需要某个资源，则会发送一个RST_STREAM帧拒绝该资源的推送流
3. 服务端在发送PUSH_PROMISE后，才可发送客户端最初的请求的响应数据以及推送资源

先发送PUSH_PROMISE帧再发送响应是因为，客户端如果在收到PUSH_PROMISE帧之前就收到了HTML响应，那么它在解析HTML发现其中的静态资源引用的时候，就会给服务器发送对该静态资源的请求。而如果先收到PUSH_PROMISE帧，客户端就知道了服务器将要推送什么资源，在解析到该资源的时候就不会去请求。

服务器发送PUSH_PROMISE帧过后即开始推送资源，但该资源客户端可能不需要，之后服务器接收到RST_STREAM帧的时候可能已经推送了部分数据了，不过这是不可避免的。

### 其他特性

#### 数据流优先级

HTML文档本身以及CSS对网页内容的构建不可或缺，而其可能收到JS、图片等其他资源的阻塞。为了加快页面加载速度，浏览器一般会基于资源类型及其在页面重的位置来排定请求的优先次序。在HTTP/1.x中，请求是顺序串行发送的，能够保证请求根据优先次序发送，但服务器存在线头阻塞问题。而在HTTP/2中，由于多路复用的原因，请求是并行的，无法保证其顺序。因此，在HTTP/2中加入了数据流优先级控制的特性。

- 实现：浏览器通过PRORITY帧声明流的优先级，服务器根据其生成或调整优先级树，并指导服务器CPU、内存、带宽等资源分配。
- 优先级定义：
  - 流依赖：
    - 每个数据流都一个关联的依赖关系，如果没有显示的依赖，则会隐式的依赖于根流Stream0。
    - 服务器根据流依赖及权重构建优先级树，只有当上一层级的所有流传输完成后，才会发送当前层级的数据流。
  - 权重：给每个流分配一个1-256之间的权重，同一层级的数据流进行传输时，根据权重分配不同的带宽比例。
  - 独占位：用于表示在不与任何其它数据流共享带宽的情况下下载。拥有独占位的流通常独占优先级树的一个层级
- 非强制：数据流依赖关系和权重表示传输优先级，而不是强制要求，因此不能保证特定的处理或传输顺序。 客户端无法强制服务器通过数据流优先级以特定顺序处理数据流，这是为了预防在优先级较高的资源受到阻止时，还阻止服务器处理优先级较低的资源。

#### 流控制

HTTP/2利用流来实现多路复用，在同个TCP连接里多个流并行传输，这可能造成流对TCP连接的争夺，导致某些流被阻塞。

HTTP/2使用流控制来确保在同一连接上的多个流之间不会造成破坏性的干扰。区别与TCP流量控制，HTTP/2的流控制粒度更小，能够作用于同一TCP连接内的具体数据流。

HTTP/2使用流控窗口实现流控制：

1. HTTP/2连接建立时，客户端与服务器交换SETTINGS帧，在两个方向上设置流控窗口；
2. 接收方收到发送方的DATA帧时，发送WINDOW_UPDATE帧减小发送端的发送窗口，减少值为该DATA帧数据大小；在处理完相关数据后，再增大发送方的发送窗口；

其他特征：

1. 方向性：由接收方控制发送方的窗口大小
2. 不能被禁用：初始窗口大小为65535
3. 只作用于DATA帧，保证重要的控制帧不会被流控阻塞
4. 算法自由：HTTP/2没有规定流控的具体算法，实现者可自行实现流控算法

# HTTPS

1. 概念：基于SSL与HTTP协议进加密传输、身份认证的安全网络传输协议；
2. 数字证书：其本质就是一对公钥和私钥
3. 默认端口443
4. 建立连接消耗较高，连接建立后的加密消耗较低

- SSL握手需要9个包，加上TCP握手3个包，HTTPS建立连接需要12个包
  - 连接建立后使用对称加密

#### 流程

1. 服务器将证书公钥发给客户端，客户端TLS解析证书，验证是否有效
2. 若无效则警告，否则生成随机值，然后用公钥对其加密，将加密后的随机值发给服务器
3. 服务器将加密随机值用私钥解密，得到随机值，
4. 之后的数据传输通过该随机值进行对称加密后传输

#### 优点

- 安全性更高
- 比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高

#### 缺点

- 占用资源较多
- 握手阶段耗时，影响网站响应速度
- 缓存不如HTTP高效，流量成本高
- 免费证书少，申请证书要钱
- SSL证书需要绑定IP，不能再一个IP上绑定多个域名，IPv4资源支撑不了这个消耗

#### URI与URL

1. URI（Uniform Resource Identifier，统一资源标识符）
   1. 用于唯一的标识一个资源；
   2. 一种抽象的，高层次概念定义统一资源标识；
2. URL（Uniform Resource Locator，统一资源定位符）
   1. 用来标识某一资源的地址
   2. 具体的资源标识方式，一种URI
   3. 组成：协议://域名或IP(可选端口号)/资源具体地址



参考：

[keep-alive](https://zhuanlan.zhihu.com/p/34052073)

[HTTP/2协议“多路复用”实现原理](https://segmentfault.com/a/1190000016975064)

[HTTP/2 头部压缩技术介绍](https://imququ.com/post/header-compression-in-http2.html)

[HTTP/2数据流优先级管理](https://jin-yang.github.io/post/linux-network-http2-protocol-introduce.html)

[理解HTTP/2流优先级](https://blog.csdn.net/liujiyong7/article/details/64478317)